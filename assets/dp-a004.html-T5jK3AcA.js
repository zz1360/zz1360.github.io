import{_ as t,c as a,o as r,a as n}from"./app-DukR-6js.js";const i={};function o(c,e){return r(),a("div",null,e[0]||(e[0]=[n('<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>不常用</p></div><h2 id="原型模式的原理与应用" tabindex="-1"><a class="header-anchor" href="#原型模式的原理与应用" aria-hidden="true">#</a> 原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。</p><h3 id="那何为-对象的创建成本比较大" tabindex="-1"><a class="header-anchor" href="#那何为-对象的创建成本比较大" aria-hidden="true">#</a> 那何为“对象的创建成本比较大”？</h3><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><h3 id="原型模式的实现方式-深拷贝和浅拷贝" tabindex="-1"><a class="header-anchor" href="#原型模式的实现方式-深拷贝和浅拷贝" aria-hidden="true">#</a> 原型模式的实现方式：深拷贝和浅拷贝</h3><p>在 Java 语言中，Object 类的 clone() 方法执行的就是浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象的内存地址，不会递归地拷贝引用对象本身。</p>',8)]))}const d=t(i,[["render",o],["__file","dp-a004.html.vue"]]);export{d as default};
