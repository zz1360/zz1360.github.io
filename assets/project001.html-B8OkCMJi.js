import{_ as n,c as e,o as s,a as i}from"./app-DukR-6js.js";const t={};function p(l,a){return s(),e("div",null,a[0]||(a[0]=[i(`<h3 id="为什么spring这么流行" tabindex="-1"><a class="header-anchor" href="#为什么spring这么流行" aria-hidden="true">#</a> 为什么Spring这么流行</h3><p>MVC架构思想并不是Spring提出来的，编程大佬不借助这些框架也能写出MVC思想的代码，但是SpringMVC的出现让一般开发者可以简单的编写出落地这种思想的代码，所以这么流行。</p><h3 id="为什么现在都谈springboot" tabindex="-1"><a class="header-anchor" href="#为什么现在都谈springboot" aria-hidden="true">#</a> 为什么现在都谈SpringBoot</h3><p>SpringBoot的基础还是这个SpringMVC，SpringBoot最大的改变就是简化了SpringMVC的配置。所谓的<strong>约定大于配置</strong>，除了说日志文件放在哪，端口号是多少这种常规配置，更多的是指比如说一个接口，如果要实例化，那么该实例化它的哪个实现类，这些配置原先是配置在xml文件的，现在SpringBoot直接自动装配了。</p><h3 id="java的精髓是抽象" tabindex="-1"><a class="header-anchor" href="#java的精髓是抽象" aria-hidden="true">#</a> Java的精髓是抽象</h3><p>Java的这些特性和Spring框架的流行都是为了写出符合OCP原则的代码来，可扩展，易维护。</p><h3 id="什么是di" tabindex="-1"><a class="header-anchor" href="#什么是di" aria-hidden="true">#</a> 什么是DI</h3><p>我们谈对象，就是谈对象与对象之间的相互作用，正是这些错综复杂的相互作用构成了我们的系统。所以，对象之间是缺少不了对其它对象的依赖的。而最显而易见的对其它对象的依赖就是new一个对象出来，这最明显，但这种方式不好。而DI这种形式，由IOC容器为我们将依赖注入进来，就属于比较好的形式了。两种比较常见的注入方式分别是：属性注入（加set方法）和构造注入（构造函数）</p><p>IOC是一种抽象的模糊的概念，而DI一般被认为是这种概念的实现或者说应用或者说另外一种描述，DI更加具体和好理解。马丁福勒就写过一篇文章，阐述了IOC和DI的关系。</p><h3 id="什么是spi" tabindex="-1"><a class="header-anchor" href="#什么是spi" aria-hidden="true">#</a> 什么是SPI</h3><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><h3 id="怎么应对变化" tabindex="-1"><a class="header-anchor" href="#怎么应对变化" aria-hidden="true">#</a> 怎么应对变化</h3><ul><li>一个接口，多个实现类，也就是策略模式。</li><li>一个接口，只有一个实现类【防御性编程，应对未来可能的变化】，但是该实现类中的属性可以发生变化，变化读取自配置文件。</li></ul><h3 id="为什么要把变化隔离到配置文件里" tabindex="-1"><a class="header-anchor" href="#为什么要把变化隔离到配置文件里" aria-hidden="true">#</a> 为什么要把变化隔离到配置文件里</h3><ul><li>集中性</li><li>配置文件的变化不违反OCP原则，因为变化无法消除，只能转移。</li></ul><h3 id="configuration出现的意义" tabindex="-1"><a class="header-anchor" href="#configuration出现的意义" aria-hidden="true">#</a> @Configuration出现的意义</h3><p>这是一种编程模式，比起单纯在一个类上打上@Component的注解，这种configuration的类更具有灵活性，更具有掌控性。</p><h3 id="自动装配" tabindex="-1"><a class="header-anchor" href="#自动装配" aria-hidden="true">#</a> 自动装配</h3><blockquote><p>为什么要有自动配置？它解决了什么问题？</p><p>主要是为了加载第三方的SDK，它提供了一种加载机制。只要我们遵守SpringBoot提供的这种机制规则，SpringBoot就能去自动装配。</p></blockquote><p>允许从配置文件中去更改配置的bean中的相关的字段的属性。第二点就是你必须要把这些bean加入到IOC容器中去。</p><h3 id="异常的理解" tabindex="-1"><a class="header-anchor" href="#异常的理解" aria-hidden="true">#</a> 异常的理解</h3><p>对于已知异常，我们抛出去主要是为了传递一种消息，为什么采用这种抛出异常的机制主要是因为有全局异常处理机制，可以比较方便的处理抛出去的异常从而可以统一返回格式。</p><h3 id="为什么很多人觉得service层面对接口编程多此一举" tabindex="-1"><a class="header-anchor" href="#为什么很多人觉得service层面对接口编程多此一举" aria-hidden="true">#</a> 为什么很多人觉得service层面对接口编程多此一举</h3><p>归根结底，还是代码粒度不够小，类承担职责过多，替换的难度很大，还不如直接改。</p><h3 id="为什么数据库多对多关系复杂" tabindex="-1"><a class="header-anchor" href="#为什么数据库多对多关系复杂" aria-hidden="true">#</a> 为什么数据库多对多关系复杂</h3><p>并不仅仅是因为多对多一般有三张表，包括中间表。而是因为有时候一张表可能跟很多表都有多对多关系，你得厘清这些表的关系。其次，中间表也分为有业务含义的和没有业务含义的。当设计多对多关系的表的时候，要考虑中间表是否包含业务含义。</p><h3 id="关于数据库表的扩展性问题思考" tabindex="-1"><a class="header-anchor" href="#关于数据库表的扩展性问题思考" aria-hidden="true">#</a> 关于数据库表的扩展性问题思考</h3><p>对于数据库表，字段是不具备扩展性的，但是记录是具备扩展性的。换句话说，列不具备扩展性，行具备扩展性。</p><h3 id="jpa的好处" tabindex="-1"><a class="header-anchor" href="#jpa的好处" aria-hidden="true">#</a> JPA的好处</h3><p>有的人觉得JPA只能做些简单查询，但其实一个项目里面百分之70都是简单查询，JPA帮助我们大大的简化了简单查询的过程。除此之外，JPA也提供了多种查询方式帮助我们执行复杂查询的任务。</p><h3 id="数据库设计" tabindex="-1"><a class="header-anchor" href="#数据库设计" aria-hidden="true">#</a> 数据库设计</h3><p>完整的数据库设计并不代表好的数据库设计，因为还没有考虑到前端的业务相关操作。</p><h3 id="关于optional" tabindex="-1"><a class="header-anchor" href="#关于optional" aria-hidden="true">#</a> 关于optional</h3><ul><li>简化我们的代码</li><li>强制我们判断空值</li></ul><h3 id="api文件夹下为什么要建v1和v2" tabindex="-1"><a class="header-anchor" href="#api文件夹下为什么要建v1和v2" aria-hidden="true">#</a> api文件夹下为什么要建V1和V2</h3><p>为了兼容性，比如有的用户不升级客户端，还是调用老的接口。</p><h3 id="如何配置热启动" tabindex="-1"><a class="header-anchor" href="#如何配置热启动" aria-hidden="true">#</a> 如何配置热启动</h3><ul><li>安装devtools依赖</li><li>optional设置为true</li><li>IDEA打开设置，搜索compiler，勾选build project automatically</li></ul><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="something" tabindex="-1"><a class="header-anchor" href="#something" aria-hidden="true">#</a> something</h3><ul><li>RocketMQ在JDK11版本下安装会有一些问题，JDK8没有这些问题。</li><li>Java为了兼容性做了很多妥协，像是泛型就没有C#等语言好用，为了兼容一些老的虚拟机。</li><li>Mac上输入<code>/usr/libexec/java_home -V</code>是可以看到所有安装的Java版本</li><li>一般开发者很少用到Maven的干预构建功能，最常用的就是引入依赖。</li><li>如果想干预构建过程，建议使用gradle，因为xml更偏向于描述性的标记语言，而gradle使用groovy这种DSL（特定领域编程语言，比如SQL也是）会更好一些。</li><li>URL的设计要有自描述性， <code>host:port/v1/资源名称/作用</code>，比如<code>host:port/v1/banner/getBannerList</code></li><li>一个好的程序员是要写出可维护的代码，Java这门语言的特性也是为了让人写出可维护的代码。</li><li>什么是好代码，不啰嗦的，自描述性的，可维护的代码。</li><li>编程过程中遇到的各种各样的概念，比如说面向对象，分层，IOC，DI，接口多态mvc架构等等这么多的概念，为什么要搞出这么多概念，这些都是为了代码的可维护。</li><li>为什么要面向抽象编程，因为要符合开闭原则，但最根本的目的，还是要写出可维护的代码。</li><li>单纯的interface可以统一方法的调用，但是不能统一对象的实例化。那么怎么统一对象的实例化呢，new这个动作还是太具体了，于是就出现了IOC、DI这些东西。</li><li>为什么越学越焦虑，因为没有那种掌控的感觉。因为没有思考过编程的本质，没有思考底层的思想演变过程，有的只是api的调用。</li><li>要带着问题看源码，而不是一上来就去看源码。</li><li>不会直接使用框架，而是在当前框架的基础上进行二次封装增强。</li><li>对于订单的状态判断，不能只是根据status这种字段来判断，得考虑到延迟支付消息丢失的情况，建议使用订单过期时间来判断。</li><li>程序员的bug很容易发现和解决，但是数据库数据的问题有时候很难发现以及很难修改，修改数据库的数据容易引起其它的问题。</li></ul><h2 id="拉勾并发课程" tabindex="-1"><a class="header-anchor" href="#拉勾并发课程" aria-hidden="true">#</a> 拉勾并发课程</h2><ul><li>所谓的Interupt是唤醒轻量级阻塞的意思。</li></ul>`,44)]))}const r=n(t,[["render",p],["__file","project001.html.vue"]]);export{r as default};
