import{_ as e,c as i,o as r,a as d}from"./app-DukR-6js.js";const h={};function n(t,a){return r(),i("div",null,a[0]||(a[0]=[d('<h2 id="常见工厂模式" tabindex="-1"><a class="header-anchor" href="#常见工厂模式" aria-hidden="true">#</a> 常见工厂模式</h2><h3 id="简单工厂模式" tabindex="-1"><a class="header-anchor" href="#简单工厂模式" aria-hidden="true">#</a> 简单工厂模式</h3><p>除了直接new对象之外，如果不同类型的对象可以复用，还可以将对象存在缓存中。</p><p>尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下是没有问题的。</p><h3 id="工厂方法" tabindex="-1"><a class="header-anchor" href="#工厂方法" aria-hidden="true">#</a> 工厂方法</h3><p>先为不同的类创建不同的简单工厂，用来创建类对象。</p><p>再为工厂类创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><h3 id="那什么时候该用工厂方法模式-而非简单工厂模式呢" tabindex="-1"><a class="header-anchor" href="#那什么时候该用工厂方法模式-而非简单工厂模式呢" aria-hidden="true">#</a> 那什么时候该用工厂方法模式，而非简单工厂模式呢？</h3><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p><p>判断要不要使用工厂模式的最本质的参考标准无外乎下面这四个：</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用： 创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h2 id="工厂模式和-di-容器有何区别" tabindex="-1"><a class="header-anchor" href="#工厂模式和-di-容器有何区别" aria-hidden="true">#</a> 工厂模式和 DI 容器有何区别？</h2><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p><h3 id="di-容器的核心功能有哪些" tabindex="-1"><a class="header-anchor" href="#di-容器的核心功能有哪些" aria-hidden="true">#</a> DI 容器的核心功能有哪些？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p>作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，需要通过一种形式，让应用告知 DI 容器要创建哪些对象，这种形式就是配置。</p>',16)]))}const p=e(h,[["render",n],["__file","dp-a002.html.vue"]]);export{p as default};
