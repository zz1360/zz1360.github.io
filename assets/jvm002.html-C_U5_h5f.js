import{_ as e,c as r,o as n,a as l}from"./app-DukR-6js.js";const i={};function s(t,a){return n(),r("div",null,a[0]||(a[0]=[l(`<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值</p></div><p><strong>默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><h2 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法" aria-hidden="true">#</a> 可达性分析算法</h2><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><h3 id="哪些对象可以作为-gc-roots-呢" tabindex="-1"><a class="header-anchor" href="#哪些对象可以作为-gc-roots-呢" aria-hidden="true">#</a> 哪些对象可以作为 GC Roots 呢？</h3><ul><li><p>虚拟机栈(栈帧中的局部变量表)中引用的对象</p></li><li><p>本地方法栈(Native 方法)中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>所有被同步锁持有的对象</p></li><li><p>JNI（Java Native Interface）引用的对象</p></li></ul><h2 id="垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集算法" aria-hidden="true">#</a> 垃圾收集算法</h2><h3 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><h3 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法" aria-hidden="true">#</a> 复制算法</h3><p>了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><h3 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法" aria-hidden="true">#</a> 标记-整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h2 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器" aria-hidden="true">#</a> 垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK22: G1</li></ul><h3 id="parallel-scavenge" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge" aria-hidden="true">#</a> Parallel Scavenge</h3><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-XX:+UseParallelGC</span>

    使用 Parallel 收集器+ 老年代串行 
    如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC
    可以使用-XX:-UseParallelOldGC 来禁用该功能

<span class="token parameter variable">-XX:+UseParallelOldGC</span>

    使用 Parallel 收集器+ 老年代并行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器" aria-hidden="true">#</a> CMS收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p><strong>初始标记：</strong> 短暂停顿，标记直接与 root 相连的对象（根对象）；</p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li></ul><p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p><h3 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器" aria-hidden="true">#</a> G1收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</li><li><strong>并发标记</strong>：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</li><li><strong>最终标记</strong>： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。</li><li><strong>筛选回收</strong>：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。</li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。<strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="zgc收集器" tabindex="-1"><a class="header-anchor" href="#zgc收集器" aria-hidden="true">#</a> ZGC收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。</p><p>ZGC 在 Java11 中引入，处于试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java15 已经可以正式使用了。</p>`,37)]))}const d=e(i,[["render",s],["__file","jvm002.html.vue"]]);export{d as default};
