import{_ as e,c as l,o as d,a}from"./app-DukR-6js.js";const i={};function n(r,t){return d(),l("div",null,t[0]||(t[0]=[a('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><table><thead><tr><th style="text-align:left;">区别点</th><th style="text-align:left;">重载方法</th><th style="text-align:left;">重写方法</th></tr></thead><tbody><tr><td style="text-align:left;">发生范围</td><td style="text-align:left;">同一个类</td><td style="text-align:left;">子类</td></tr><tr><td style="text-align:left;">参数列表</td><td style="text-align:left;">必须修改</td><td style="text-align:left;">一定不能修改</td></tr><tr><td style="text-align:left;">返回类型</td><td style="text-align:left;">可修改</td><td style="text-align:left;">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td style="text-align:left;">异常</td><td style="text-align:left;">可修改</td><td style="text-align:left;">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td style="text-align:left;">访问修饰符</td><td style="text-align:left;">可修改</td><td style="text-align:left;">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td style="text-align:left;">发生阶段</td><td style="text-align:left;">编译期</td><td style="text-align:left;">运行期</td></tr></tbody></table><hr><h3 id="静态方法为什么不能访问非静态成员" tabindex="-1"><a class="header-anchor" href="#静态方法为什么不能访问非静态成员" aria-hidden="true">#</a> 静态方法为什么不能访问非静态成员</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol>',6)]))}const f=e(i,[["render",n],["__file","basic005.html.vue"]]);export{f as default};
