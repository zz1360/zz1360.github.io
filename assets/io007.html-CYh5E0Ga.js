import{_ as a,c as s,o as e,a as t}from"./app-DukR-6js.js";const i={};function l(o,n){return e(),s("div",null,n[0]||(n[0]=[t(`<p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p><p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU 拷贝</th><th>DMA 拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方法</td><td>2</td><td>2</td><td>read+write</td><td>4</td></tr><tr><td>mmap+write</td><td>1</td><td>2</td><td>mmap+write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile + DMA gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr></tbody></table><p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p><p>Java 对零拷贝的支持：</p><ul><li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li><li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区。</li></ul><h2 id="什么是零拷贝" tabindex="-1"><a class="header-anchor" href="#什么是零拷贝" aria-hidden="true">#</a> 什么是零拷贝</h2><p>零拷贝字面上的意思包括两个，“零”和“拷贝”：</p><ul><li>“拷贝”：就是指数据从一个存储区域转移到另一个存储区域。</li><li>“零” ：表示次数为0，它表示拷贝数据的次数为0。</li></ul><p>合起来，那<strong>零拷贝</strong>就是不需要将数据从一个存储区域复制到另一个存储区域咯。</p><blockquote><p><strong>零拷贝</strong>是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种<code>I/O</code>操作优化技术。</p></blockquote><h2 id="传统io执行流程" tabindex="-1"><a class="header-anchor" href="#传统io执行流程" aria-hidden="true">#</a> 传统IO执行流程</h2><p>传统的IO流程，包括read和write的过程。</p><ul><li><code>read</code>：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li><code>write</code>：先把数据写入到socket缓冲区，最后写入网卡设备。</li></ul><p>流程如下：</p><ul><li>用户应用进程调用read函数，向操作系统发起IO调用， <strong>上下文从用户态转为内核态（切换1）</strong></li><li>DMA控制器把数据从磁盘中，读取到内核缓冲区。</li><li>CPU把内核缓冲区数据，拷贝到用户应用缓冲区， <strong>上下文从内核态转为用户态（切换2）</strong>，read函数返回</li><li>用户应用进程通过write函数，发起IO调用， <strong>上下文从用户态转为内核态（切换3）</strong></li><li>CPU将用户缓冲区中的数据，拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区，拷贝到网卡设备， <strong>上下文从内核态切换回用户态（切换4）</strong>，write函数返回</li></ul><p>可以看出，<strong>传统IO的读写流程</strong>，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（<strong>两次CPU拷贝以及两次的DMA拷贝</strong>)，什么是DMA拷贝呢？我们一起来回顾下，零拷贝涉及的<strong>操作系统知识点</strong>哈。</p><h2 id="零拷贝相关的知识点回顾" tabindex="-1"><a class="header-anchor" href="#零拷贝相关的知识点回顾" aria-hidden="true">#</a> 零拷贝相关的知识点回顾</h2><h3 id="_3-1-内核空间和用户空间" tabindex="-1"><a class="header-anchor" href="#_3-1-内核空间和用户空间" aria-hidden="true">#</a> 3.1 内核空间和用户空间</h3><p>我们电脑上跑着的应用程序，其实是需要经过<strong>操作系统</strong>，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，<strong>不可以由应用程序乱来</strong>，只能交给底层操作系统来。</p><p>因此，操作系统为每个进程都分配了内存空间，一部分是用户空间，一部分是内核空间。<strong>内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。</strong> 以32位操作系统为例，它会为每一个进程都分配了<strong>4G</strong>(2的32次方)的内存空间。</p><ul><li>内核空间：主要提供进程调度、内存分配、连接硬件资源等功能</li><li>用户空间：提供给各个程序进程的空间，它不具有访问内核空间资源的权限，如果应用程序需要使用到内核空间的资源，则需要通过系统调用来完成。进程从用户空间切换到内核空间，完成相关操作后，再从内核空间切换回用户空间。</li></ul><h3 id="_3-2-什么是用户态、内核态" tabindex="-1"><a class="header-anchor" href="#_3-2-什么是用户态、内核态" aria-hidden="true">#</a> 3.2 什么是用户态、内核态</h3><ul><li>如果进程运行于内核空间，被称为进程的内核态</li><li>如果进程运行于用户空间，被称为进程的用户态。</li></ul><h3 id="_3-3-什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#_3-3-什么是上下文切换" aria-hidden="true">#</a> 3.3 什么是上下文切换</h3><ul><li>什么是CPU上下文？</li></ul><blockquote><p>CPU 寄存器，是CPU内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此叫做CPU上下文。</p></blockquote><ul><li>什么是 <strong>CPU上下文切换</strong>？</li></ul><blockquote><p>它是指，先把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p></blockquote><p>一般我们说的<strong>上下文切换</strong>，就是指内核（操作系统的核心）在CPU上对进程或者线程进行切换。进程从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。系统调用的过程，会发生<strong>CPU上下文的切换</strong>。</p><blockquote><p>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</p></blockquote><h3 id="_3-4-虚拟内存" tabindex="-1"><a class="header-anchor" href="#_3-4-虚拟内存" aria-hidden="true">#</a> 3.4 虚拟内存</h3><p>现代操作系统使用虚拟内存，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：</p><ul><li>虚拟内存空间可以远远大于物理内存空间</li><li>多个虚拟内存可以指向同一个物理地址</li></ul><p>正是<strong>多个虚拟内存可以指向同一个物理地址</strong>，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，就可以减少IO的数据拷贝次数啦。</p><h3 id="_3-5-dma技术" tabindex="-1"><a class="header-anchor" href="#_3-5-dma技术" aria-hidden="true">#</a> 3.5 DMA技术</h3><p>DMA，英文全称是<strong>Direct Memory Access</strong>，即直接内存访问。<strong>DMA</strong>本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程<strong>不需要CPU的参与</strong>。</p><p>IO流程，DMA帮忙做了什么事情：</p><ul><li>用户应用进程调用read函数，向操作系统发起IO调用，进入阻塞状态，等待数据返回。</li><li>CPU收到指令后，对DMA控制器发起指令调度。</li><li>DMA收到IO请求后，将请求发送给磁盘；</li><li>磁盘将数据放入磁盘控制缓冲区，并通知DMA</li><li>DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。</li><li>DMA向CPU发出数据读完的信号，把工作交换给CPU，由CPU负责将数据从内核缓冲区拷贝到用户缓冲区。</li><li>用户应用进程由内核态切换回用户态，解除阻塞状态</li></ul><p>可以发现，DMA做的事情很清晰啦，它主要就是<strong>帮忙CPU转发一下IO请求，以及拷贝数据</strong>。为什么需要它的？</p><blockquote><p>主要就是效率，它帮忙CPU做事情，这时候，CPU就可以闲下来去做别的事情，提高了CPU的利用效率。大白话解释就是，CPU老哥太忙太累啦，所以他找了个小弟（名叫DMA） ，替他完成一部分的拷贝工作，这样CPU老哥就能着手去做其他事情。</p></blockquote><h2 id="零拷贝的几种实现方式" tabindex="-1"><a class="header-anchor" href="#零拷贝的几种实现方式" aria-hidden="true">#</a> 零拷贝的几种实现方式</h2><p>零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。零拷贝实现有多种方式，分别是</p><ul><li>mmap+write</li><li>sendfile</li><li>带有DMA收集拷贝功能的sendfile</li></ul><h3 id="_4-1-mmap-write实现的零拷贝" tabindex="-1"><a class="header-anchor" href="#_4-1-mmap-write实现的零拷贝" aria-hidden="true">#</a> 4.1 mmap+write实现的零拷贝</h3><p>mmap 的函数原型如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>addr：指定映射的虚拟内存地址</li><li>length：映射的长度</li><li>prot：映射内存的保护模式</li><li>flags：指定映射的类型</li><li>fd:进行映射的文件句柄</li><li>offset:文件偏移量</li></ul><p>前面一小节，零拷贝相关的知识点回顾，我们介绍了<strong>虚拟内存</strong>，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，从而减少数据拷贝次数！mmap就是用了虚拟内存这个特点，它将内核中的读缓冲区与用户空间的缓冲区进行映射，所有的IO都在内核中完成。</p><p><code>mmap+write</code>实现的零拷贝流程如下：</p><ul><li>用户进程通过 <code>mmap方法</code>向操作系统内核发起IO调用， <strong>上下文从用户态切换为内核态</strong>。</li><li>CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li><strong>上下文从内核态切换回用户态</strong>，mmap方法返回。</li><li>用户进程通过 <code>write</code>方法向操作系统内核发起IO调用， <strong>上下文从用户态切换为内核态</strong>。</li><li>CPU将内核缓冲区的数据拷贝到的socket缓冲区。</li><li>CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡， <strong>上下文从内核态切换回用户态</strong>，write调用返回。</li></ul><p>可以发现，<code>mmap+write</code>实现的零拷贝，I/O发生了<strong>4</strong>次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了<strong>2次DMA拷贝和1次CPU拷贝</strong>。</p><p><code>mmap</code>是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝‘’并且用户进程内存是<strong>虚拟的</strong>，只是<strong>映射</strong>到内核的读缓冲区，可以节省一半的内存空间。</p><h3 id="_4-2-sendfile实现的零拷贝" tabindex="-1"><a class="header-anchor" href="#_4-2-sendfile实现的零拷贝" aria-hidden="true">#</a> 4.2 sendfile实现的零拷贝</h3><p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，API如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>out_fd:为待写入内容的文件描述符，一个socket描述符。，</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><p>sendfile表示在两个文件描述符之间传输数据，它是在<strong>操作系统内核</strong>中操作的，<strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</strong>，因此可以使用它来实现零拷贝。</p><p>sendfile实现的零拷贝流程如下：</p><ol><li>用户进程发起sendfile系统调用， <strong>上下文（切换1）从用户态转向内核态</strong></li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU将读缓冲区中数据拷贝到socket缓冲区</li><li>DMA控制器，异步把数据从socket缓冲区拷贝到网卡，</li><li><strong>上下文（切换2）从内核态切换回用户态</strong>，sendfile调用返回。</li></ol><p>可以发现，<code>sendfile</code>实现的零拷贝，I/O发生了<strong>2</strong>次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了<strong>2次DMA拷贝和1次CPU拷贝</strong>。那能不能把CPU拷贝的次数减少到0次呢？有的，即<code>带有DMA收集拷贝功能的sendfile</code>！</p><h3 id="_4-3-sendfile-dma-scatter-gather实现的零拷贝" tabindex="-1"><a class="header-anchor" href="#_4-3-sendfile-dma-scatter-gather实现的零拷贝" aria-hidden="true">#</a> 4.3 sendfile+DMA scatter/gather实现的零拷贝</h3><p>linux 2.4版本之后，对<code>sendfile</code>做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了<code>scatter/gather</code>操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点搞零拷贝，即还可以多省去<strong>一次CPU拷贝</strong>。</p><p>sendfile+DMA scatter/gather实现的零拷贝流程如下：</p><ol><li>用户进程发起sendfile系统调用， <strong>上下文（切换1）从用户态转向内核态</strong></li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU把内核缓冲区中的 <strong>文件描述符信息</strong>（包括内核缓冲区的内存地址和偏移量）发送到socket缓冲区</li><li>DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡</li><li><strong>上下文（切换2）从内核态切换回用户态</strong>，sendfile调用返回。</li></ol><p>可以发现，<code>sendfile+DMA scatter/gather</code>实现的零拷贝，I/O发生了<strong>2</strong>次用户空间与内核空间的上下文切换，以及2次数据拷贝。其中2次数据拷贝都是包<strong>DMA拷贝</strong>。这就是真正的 <strong>零拷贝（Zero-copy)</strong> 技术，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。</p><h2 id="java提供的零拷贝技术" tabindex="-1"><a class="header-anchor" href="#java提供的零拷贝技术" aria-hidden="true">#</a> Java提供的零拷贝技术</h2><ul><li>Java NIO对mmap的支持</li><li>Java NIO对sendfile的支持</li></ul><h3 id="_5-1-java-nio对mmap的支持" tabindex="-1"><a class="header-anchor" href="#_5-1-java-nio对mmap的支持" aria-hidden="true">#</a> 5.1 Java NIO对mmap的支持</h3><p>Java NIO有一个<code>MappedByteBuffer</code>的类，可以用来实现内存映射。它的底层是调用了Linux内核的<strong>mmap</strong>的API。</p><p><strong>mmap的小demo</strong>如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MmapTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">FileChannel</span> readChannel <span class="token operator">=</span> <span class="token class-name">FileChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;./jay.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardOpenOption</span><span class="token punctuation">.</span><span class="token constant">READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">MappedByteBuffer</span> data <span class="token operator">=</span> readChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">FileChannel<span class="token punctuation">.</span>MapMode</span><span class="token punctuation">.</span><span class="token constant">READ_ONLY</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">FileChannel</span> writeChannel <span class="token operator">=</span> <span class="token class-name">FileChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;./siting.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardOpenOption</span><span class="token punctuation">.</span><span class="token constant">WRITE</span><span class="token punctuation">,</span> <span class="token class-name">StandardOpenOption</span><span class="token punctuation">.</span><span class="token constant">CREATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//数据传输</span>
            writeChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            readChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            writeChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-java-nio对sendfile的支持" tabindex="-1"><a class="header-anchor" href="#_5-2-java-nio对sendfile的支持" aria-hidden="true">#</a> 5.2 Java NIO对sendfile的支持</h3><p>FileChannel的<code>transferTo()/transferFrom()</code>，底层就是sendfile() 系统调用函数。Kafka 这个开源项目就用到它，平时面试的时候，回答面试官为什么这么快，就可以提到零拷贝<code>sendfile</code>这个点。</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@Override
public long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {
   return fileChannel.transferTo(position, count, socketChannel);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>sendfile的小demo</strong>如下：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public class SendFileTest {
    public static void main(String[] args) {
        try {
            FileChannel readChannel = FileChannel.open(Paths.get(&quot;./jay.txt&quot;), StandardOpenOption.READ);
            long len = readChannel.size();
            long position = readChannel.position();
            
            FileChannel writeChannel = FileChannel.open(Paths.get(&quot;./siting.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
            //数据传输
            readChannel.transferTo(position, len, writeChannel);
            readChannel.close();
            writeChannel.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,78)]))}const c=a(i,[["render",l],["__file","io007.html.vue"]]);export{c as default};
