import{_ as e,c as r,o as t,a as n}from"./app-DukR-6js.js";const i={};function s(o,a){return t(),r("div",null,a[0]||(a[0]=[n('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>反射的真正价值在于，处理编译时未知的类型，从而编写更具有通用性的代码。</p><h3 id="反射的优缺点" tabindex="-1"><a class="header-anchor" href="#反射的优缺点" aria-hidden="true">#</a> 反射的优缺点</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p><p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p><h2 id="反射的应用" tabindex="-1"><a class="header-anchor" href="#反射的应用" aria-hidden="true">#</a> 反射的应用</h2><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>',9)]))}const c=e(i,[["render",s],["__file","basic011.html.vue"]]);export{c as default};
