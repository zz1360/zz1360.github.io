import{_ as n,r as o,c as i,o as s,a as d,b as e,f as r,d as l}from"./app-DukR-6js.js";const J={},p={href:"https://www.graalvm.org/",target:"_blank",rel:"noopener noreferrer"};function T(h,a){const t=o("ExternalLinkIcon");return s(),i("div",null,[a[3]||(a[3]=d('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>字节码是Java虚拟机JVM能够理解的语言，即扩展名是<code>.class</code> 的文件。并不是只有Java语言编译之后是字节码，还有kotlin、groovy等语言也可以编译成字节码在JVM上运行。字节码不面向任何特定的处理器，只面向JVM。字节码经解释器逐行解释成机器码执行，这种方式的执行速度相对而言就比较慢，所以从Java2开始就引入了JIT编译器，可以将热点代码编译成的机器码保存起来，这样下次就可以直接使用了，而机器码的运行效率肯定是高于逐行解释的，这也说明了为什么Java是解释和编译同时存在的。</p><h2 id="jit" tabindex="-1"><a class="header-anchor" href="#jit" aria-hidden="true">#</a> JIT</h2><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><h2 id="aot" tabindex="-1"><a class="header-anchor" href="#aot" aria-hidden="true">#</a> AOT</h2><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p>AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>',7)),e("p",null,[a[1]||(a[1]=r("提到 AOT 就不得不提 ")),e("a",p,[a[0]||(a[0]=r("GraalVM")),l(t)]),a[2]||(a[2]=r(" 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。"))]),a[4]||(a[4]=e("h3",{id:"当前aot面临的问题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#当前aot面临的问题","aria-hidden":"true"},"#"),r(" 当前AOT面临的问题")],-1)),a[5]||(a[5]=e("p",null,"因为这种模式属于静态编译了，所以AOT编译无法支持Java的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了。如果想使用，就需要针对性地去做适配和优化。对于Spring来说，就在Spring6 中发布了 Spring AOT 机制，用来支持 Spring 应用的静态化预处理。",-1))])}const f=n(J,[["render",T],["__file","basic002.html.vue"]]);export{f as default};
