import{_ as o,c as n,o as r,a as s}from"./app-DukR-6js.js";const l={};function a(f,e){return r(),n("div",null,e[0]||(e[0]=[s(`<p>大家都知道，如果我们要访问数据库，必须得跟数据库建立一个网络连接，那么这个连接由谁来建立呢？其实答案就是这个MySQL驱动，他会在底层跟数据库建立网络连接，有网络连接，接着才能去发送请求给数据库服务器！所以对于Java语言开发的系统，MySQL会提供Java版本的MySQL驱动，对于PHP、Perl、.NET、Python、Ruby等各种常见的编程语 言，MySQL都会提供对应语言的MySQL驱动，让各种语言编写的系统通过MySQL驱动去访问数据库。</p><p>多个线程并发访问数据库的时候，如果都基于MySQL驱动去创建一个数据库连接，然后执行SQL语句，然后执行完 之后再销毁这个数据库连接，也是非常不好的，因为每次建立一个数据库连接都很耗时，好不容易建立好了连接，执行完了SQL语句，你还把数据库连接给销毁 了，下一次再重新建立数据库连接，那肯定是效率很低下的！所以一般我们必须要使用一个数据库连接池，也就是说在一个池子里维持多个数据库连接，让多个线程使用里面的不同的数据库连接去 执行SQL语句，然后执行完SQL语句之后，不要销毁这个数据库连接，而是把连接放回池子里，后续还可以继续使用，常见的数据库连接池有DBCP，C3P0，Druid，等等。</p><p>肯定会有很多系统要与MySQL数据库建立很多个连接，那么 MySQL也必然要维护与系统之间的多个连接，所以MySQL架构体系中的第一个环节，就是连接池。实际上MySQL中的连接池就是维护了与系统之间的多个数据库连接。除此之外，你的系统每次跟MySQL建立连接的 时候，还会根据你传递过来的账号和密码，进行账号密码的验证，库表权限的验证。</p><blockquote><p>网络连接必须得分配给一个线程去进行处理，由一个线程来监听请求以及读取请求数据，比如从网络连接中读取和解析出来一 条我们的系统发送过去的SQL语句</p></blockquote><p>MySQL的工作线程接收到SQL语句之后，就会转交给SQL接口去执行，SQL接口把这条SQL交给查询解析器，这个查询解析器（Parser）就是负责对SQL语句进行解析，理解这个SQL语句要干 什么事情。接着会找查询优化器（Optimizer）来选择一个最优的查询路径。最后一步，就是把查询优化器选择的最优查询路径，让执行器会根据优化器选择的执行方案，去调用存储引擎的接口按照一定的顺序和步骤，就把SQL语句的逻辑给执行了。</p><blockquote><p>数据库自己就是一个编程语言写出来的系统而已，然后启动之后也是一个进程，执行他里面的各种代码，也就是我们上面所说 的那些东西。所以对数据库而言，我们的数据要不然是放在内存里，要不然是放在磁盘文件里，没什么特殊的地方！</p></blockquote><p>存储引擎其实就是执行SQL语句的，他会按照一定的步骤去查询内存缓存数据，更新磁盘数 据，查询磁盘数据，等等，执行诸如此类的一系列的操作。</p><p>MySQL的架构设计中，SQL接口、SQL解析器、查询优化器其实都是通用的，他就是一套组件而已。但是存储引擎的话，他是支持各种各样的存储引擎的，比如我们常见的InnoDB、MyISAM、Memory等等，我们是可以选择 使用哪种存储引擎来负责具体的SQL语句执行的，当然现在MySQL一般都是使用InnoDB存储引擎的。</p><p>InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了。</p><p>Buffer Pool就是数据库的一个内存组件，里面缓存了磁盘上的真实数据，然后我们的Java系统对数据库执行的增删改操 作，其实主要就是对这个内存数据结构中的缓存数据执行的。Buffer Pool默认情况下是128MB，如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存，如下配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>server<span class="token punctuation">]</span> 
innodb_buffer_pool_size <span class="token operator">=</span> <span class="token number">2147483648</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我 们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据.所以实际上假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页 直接给加载到Buffer Pool里去，也就是说，Buffer Pool中存放的是一个一个的数据页。默认情况下，磁盘中存放的数据页的大小是16KB，也就是说，一页数据包含了16KB的内容。而Buffer Pool中存放的一个一个的数据页，我们通常叫做缓存页，因为毕竟Buffer Pool是一个缓冲池，里面的数据都是从磁 盘缓存到内存去的。而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。对于每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的，这个描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面， 然后各个缓存页放在后面。Buffer Pool中的描述数据大概相当于缓存页大小的5%左右，也就是每个描述数据大概是800个字 节左右的大小，然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130 多MB的样子，因为他里面还要存放每个缓存页的描述数据。</p><p>数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区 域，作为Buffer Pool的内存区域。然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在 Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据。只不过这个时候，Buffer Pool中的一个一个的缓存页都是空的，里面什么都没有，要等数据库运行起来之后，当我们要对数据 执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中。数据库为Buffer Pool设计一个free链表，他是一个双向链表数据结构，这个free链表里，每个节点就是一个空闲的缓存页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中。除此之外，这个free链表有一个基础节点，他会引用链表的头节点和尾节点，里面还存储了链表中有多少个描述数据块的节点，也就是有多少个空闲的缓存页。这个free链表，他本身其实就是由Buffer Pool里的描述数据块组成的，你可以认为是每个描述数据 块里都有两个指针，一个是free_pre，一个是free_next，分别指向自己的上一个free链表的节点，以及下一个free链表的节点。对于free链表而言，只有一个基础节点是不属于Buffer Pool的，他是40字节大小的一个节点，里面就存放了free链表的头节点 的地址，尾节点的地址，还有free链表里当前有多少个节点。</p><p>我们在执行增删改查的时候，肯定是先看看这个数据页有没有被缓存，如果没被缓存就走上面的逻辑，从free链表中找到一个 空闲的缓存页，从磁盘上读取数据页写入缓存页，写入描述数据，从free链表中移除这个描述数据块。但是如果数据页已经被缓存了，那么就会直接使用了。</p><p>数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。当你要使用一个数据页的时候，通过“表空间号+数据页号”作为key去这个哈希表里查一下，如果没有就读取数据页，如果 已经有了，就说明数据页已经被缓存了。</p><p>在内存里更新的脏页的数据，都是要被刷新回磁盘文件的，但不可能所有的缓存页都刷回磁盘的，因为有的缓存页可能是因为查询的时候被读取到Buffer Pool里 去的，可能根本没修改过！所以数据库在这里引入了另外一个跟free链表类似的flush链表，这个flush链表本质也是通过缓存页的描述数据块中的两个指 针，让被修改过的缓存页的描述数据块，组成一个双向链表。凡是被修改过的缓存页，都会把他的描述数据块加入到flush链表中去，flush的意思就是这些都是脏页，后续都是要flush刷新 到磁盘上去的。通过这个flush链表，就可以记录下来哪些缓存页是脏页了！</p><p>如果所有的缓存页都被塞了数据了，此时无法从磁盘上加载新的数据页到 缓存页里去了，那么此时你只有一个办法，就是淘汰掉一些缓存页。你必须把一个缓存页里被修改过的数据，给他刷到磁盘上的数据页里去，然后这个缓存页就可以清空了， 让他重新变成一个空闲的缓存页。接着你再把磁盘上你需要的新的数据页加载到这个腾出来的空闲缓存页中去。</p><p>这时候就需要一个LRU链表了。当我们从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链表头部去，那么只要有数据的缓存页，他都会在LRU里了，而且最近被加载数据的缓存页，都会放到LRU链表的头部。然后假设某个缓存页的描述数据块本来在LRU链表的尾部，后续你只要查询或者修改了这个缓存页的数据，也要把这 个缓存页挪动到LRU链表的头部去，也就是说最近被访问过的缓存页，一定在LRU链表的头部，那么这样的话，当你的缓存页没有一个空闲的时候，你是不是要找出来那个最近最少被访问的缓存页去刷入磁盘？此 时你就直接在LRU链表的尾部找到一个缓存页，他一定是最近最少被访问的那个缓存页！然后你就把LRU链表尾部的那个缓存页刷入磁盘中，然后把你需要的磁盘数据页加载到腾出来的空闲缓存页中就可以 了！</p><p>但是MySQL的预读机制可能会带来隐患，导致不怎么会被访问的数据页放在LRU链表的前面去了。还有一种可能导致频繁被访问的缓存页被淘汰的场景，那就是全表扫描，会导致他直接一下子把这个表里所有的数据页，都从磁盘加载到Buffer Pool里去。此时可能LRU链表中排在前面的一大 串缓存页，都是全表扫描加载进来的缓存页！此时LRU链表的尾部，可能全部都是之前一直被频繁访问的那些缓存页！然后当你要淘汰掉一些缓存页腾出空间的时候，就会把LRU链表尾部一直被频繁访问的缓存页给淘汰掉了，而留下了 之前全表扫描加载进来的大量的不经常访问的缓存页！</p><p>为了解决这些问题，真正MySQL在设计LRU链表的时候，采取的实际上是冷热数据 分离的思想。真正的LRU链表，会被拆分为两个部分，一部分是热数据，一部分是冷数据，这个冷热数据的比例是由 innodb_old_blocks_pct参数控制的，他默认是37，也就是说冷数据占比37%。首先数据页第一次被加载到缓存的时候，缓存页会被放在冷数据区域的链表头部。同时，一个数据页被加载到缓存页的冷数据区域头部之后，在1s之后，你访问这个缓存页，他才会被挪动到热数据区域的链表头部去。</p><p>另外，LRU链表的热数据区域的访问规则被优化了一下，即你只有在热数据区域的后3/4部分的缓存页被访问了，才会给你移动到链表头部去。如果你是热数据区域的前面1/4的缓存页被访问，他是不会移动到链表头部去的。举个例子，假设热数据区域的链表里有100个缓存页，那么排在前面的25个缓存页，他即使被访问了，也不会移动到 链表头部去的。但是对于排在后面的75个缓存页，他只要被访问，就会移动到链表头部去。这样的话，他就可以尽可能的减少链表中的节点移动了。</p><h2 id="生产经验" tabindex="-1"><a class="header-anchor" href="#生产经验" aria-hidden="true">#</a> 生产经验</h2><h3 id="多个buffer-pool优化并发能力" tabindex="-1"><a class="header-anchor" href="#多个buffer-pool优化并发能力" aria-hidden="true">#</a> 多个Buffer Pool优化并发能力</h3><p>一般来说，MySQL默认的规则是，如果你给Buffer Pool分配的内存小于1GB，那么最多就只会给你一个Buffer Pool。</p><p>但是如果你的机器内存很大，那么你必然会给Buffer Pool分配较大的内存，比如给他个8G内存，那么此时你是同时可 以设置多个Buffer Pool的，比如说下面的MySQL服务器端的配置。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>server<span class="token punctuation">]</span> 
innodb_buffer_pool_size <span class="token operator">=</span> <span class="token number">8589934592</span> 
innodb_buffer_pool_instances <span class="token operator">=</span> <span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们给buffer pool设置了8GB的总内存，然后设置了他应该有4个Buffer Pool，此时就是说，每个buffer pool的大小 就是2GB。这个时候，MySQL在运行的时候就会有4个Buffer Pool了！每个Buffer Pool负责管理一部分的缓存页和描述数据块， 有自己独立的free、flush、lru等链表。这个时候，假设多个线程并发过来访问，那么不就可以把压力分散开来了吗？有的线程访问这个buffer pool，有的线 程访问那个buffer pool。</p><p>通常来说，我们建议一个比较合理的、健康的比例，是给buffer pool设置你的机器内存的50%~60%左右。比如你有32GB的机器，那么给buffer设置个20GB的内存，剩下的留给OS和其他人来用，这样比较合理一些。假设你的机器是128GB的内存，那么buffer pool可以设置个80GB左右，大概就是这样的一个规则。</p><p>buffer pool总大小=(chunk大小 * buffer pool数量)的倍数</p><p>通过 <code>SHOW ENGINE INNODB STATUS</code> 命令查看具体情况：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（1）Total memory allocated，这就是说buffer pool最终的总大小是多少 
（2）Buffer pool size，这就是说buffer pool一共能容纳多少个缓存页 
（3）Free buffers，这就是说free链表中一共有多少个空闲的缓存页是可用的 
（4）Database pages和Old database pages，就是说lru链表中一共有多少个缓存页，以及冷数据区域里的缓存页 数量 
（5）Modified db pages，这就是flush链表中的缓存页数量 
（6）Pending reads和Pending writes，等待从磁盘上加载进缓存页的数量，还有就是即将从lru链表中刷入磁盘的数 量、即将从flush链表中刷入磁盘的数量
（7）Pages made young和not young，这就是说已经lru冷数据区域里访问之后转移到热数据区域的缓存页的数 量，以及在lru冷数据区域里1s内被访问了没进入热数据区域的缓存页的数量 
（8）youngs/s和not youngs/s，这就是说每秒从冷数据区域进入热数据区域的缓存页的数量，以及每秒在冷数据区 域里被访问了但是不能进入热数据区域的缓存页的数量
（9）Pages read xxxx, created xxx, written xxx，xx reads/s, xx creates/s, 1xx writes/s，这里就是说已经读取、 创建和写入了多少个缓存页，以及每秒钟读取、创建和写入的缓存页数量 
（10）Buffer pool hit rate xxx / 1000，这就是说每1000次访问，有多少次是直接命中了buffer pool里的缓存的 
（11）young-making rate xxx / 1000 not xx / 1000，每1000次访问，有多少次访问让缓存页从冷数据区域移动到了热数据区域，以及没移动的缓存页数量
（12）LRU len：这就是lru链表里的缓存页的数量 
（13）I/O sum：最近50s读取磁盘页的总数 
（14）I/O cur：现在正在读取磁盘页的数量
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31)]))}const i=o(l,[["render",a],["__file","mysql102.html.vue"]]);export{i as default};
