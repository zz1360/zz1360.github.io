import{_ as e,c as i,o as r,a as t}from"./app-DukR-6js.js";const d={};function h(n,a){return r(),i("div",null,a[0]||(a[0]=[t('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>由于一个进程的地址被划分为内核空间和用户空间，我们的应用是运行在用户空间中的，所以无法直接调用系统态级别的资源，比如IO操作，所以我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h2 id="java中常见的三种io模型" tabindex="-1"><a class="header-anchor" href="#java中常见的三种io模型" aria-hidden="true">#</a> Java中常见的三种IO模型</h2><h3 id="bio" tabindex="-1"><a class="header-anchor" href="#bio" aria-hidden="true">#</a> BIO</h3><p>同步阻塞模型。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><h3 id="nio" tabindex="-1"><a class="header-anchor" href="#nio" aria-hidden="true">#</a> NIO</h3><p>Java1.4 版本引入。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。</p><h3 id="aio" tabindex="-1"><a class="header-anchor" href="#aio" aria-hidden="true">#</a> AIO</h3><p>异步IO。基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>',12)]))}const s=e(d,[["render",h],["__file","io004.html.vue"]]);export{s as default};
