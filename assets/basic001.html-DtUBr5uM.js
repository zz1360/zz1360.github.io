import{_ as i,r as o,c as h,o as l,a as t,b as e,f as r,d as n}from"./app-DukR-6js.js";const s={},c={href:"http://openjdk.java.net/jeps/282",target:"_blank",rel:"noopener noreferrer"},p={href:"https://blog.csdn.net/21aspnet/article/details/7387373",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.zhihu.com/question/65576774",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html#top",target:"_blank",rel:"noopener noreferrer"};function v(J,a){const d=o("ExternalLinkIcon");return l(),h("div",null,[a[6]||(a[6]=t('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Java是一门面向对象的语言，具有封装、继承、多态的特点，具备异常处理和自动内存管理机制，编译与解释并存，可以一次编译，到处运行。但在我看来，无论是面向对象还是四处运行，都不是目前Java最大的卖点，Java强大的生态才是！</p><h2 id="面向对象和面向过程" tabindex="-1"><a class="header-anchor" href="#面向对象和面向过程" aria-hidden="true">#</a> 面向对象和面向过程</h2><h3 id="oop有哪些优势" tabindex="-1"><a class="header-anchor" href="#oop有哪些优势" aria-hidden="true">#</a> OOP有哪些优势</h3><h4 id="应对大规模复杂程序的开发" tabindex="-1"><a class="header-anchor" href="#应对大规模复杂程序的开发" aria-hidden="true">#</a> 应对大规模复杂程序的开发</h4><h4 id="更易复用、易扩展、易维护" tabindex="-1"><a class="header-anchor" href="#更易复用、易扩展、易维护" aria-hidden="true">#</a> 更易复用、易扩展、易维护</h4><h4 id="更加人性化" tabindex="-1"><a class="header-anchor" href="#更加人性化" aria-hidden="true">#</a> 更加人性化</h4><h3 id="看似面向对象-实际上面向过程的代码" tabindex="-1"><a class="header-anchor" href="#看似面向对象-实际上面向过程的代码" aria-hidden="true">#</a> 看似面向对象，实际上面向过程的代码</h3><h2 id="jdk和jre" tabindex="-1"><a class="header-anchor" href="#jdk和jre" aria-hidden="true">#</a> JDK和JRE</h2>',9)),e("p",null,[a[1]||(a[1]=r("JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。 不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ ")),e("a",c,[a[0]||(a[0]=r("jlink")),n(d)]),a[2]||(a[2]=r("工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。"))]),a[7]||(a[7]=t('<blockquote><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，</p><p>创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p></blockquote><p>也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的JRE。 定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。 这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。</p><h2 id="java-和-c-的区别" tabindex="-1"><a class="header-anchor" href="#java-和-c-的区别" aria-hidden="true">#</a> Java 和 C++ 的区别?</h2><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>……</li></ul><h2 id="移位操作符" tabindex="-1"><a class="header-anchor" href="#移位操作符" aria-hidden="true">#</a> 移位操作符</h2><p>移位操作符实际上支持的类型只有 <code>int</code>和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前， 都会将其转换为 <code>int</code>类型再操作。</p><h2 id="按位与、或、异或等运算方法" tabindex="-1"><a class="header-anchor" href="#按位与、或、异或等运算方法" aria-hidden="true">#</a> 按位与、或、异或等运算方法</h2>',8)),e("p",null,[e("a",p,[a[3]||(a[3]=r("参考博客")),n(d)])]),a[8]||(a[8]=t('<h2 id="包装类型" tabindex="-1"><a class="header-anchor" href="#包装类型" aria-hidden="true">#</a> 包装类型</h2><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h4><p>除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p><h4 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> 存储方式</h4><p>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p><h4 id="比较方式" tabindex="-1"><a class="header-anchor" href="#比较方式" aria-hidden="true">#</a> 比较方式</h4><p>对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <strong>equals()</strong> 方法。</p><h2 id="string为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#string为什么是不可变的" aria-hidden="true">#</a> String为什么是不可变的？</h2><p>我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。<code>String</code> 真正不可变有下面几点原因：</p><p>1.保存字符串的数组被 <code>final</code> 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</p><p>2.<code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p><p>需要补充的是：在 Java 9 之后，String、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串。</p><h2 id="为什么程序里1-1-0返回true-1-1-float-1-1返回false" tabindex="-1"><a class="header-anchor" href="#为什么程序里1-1-0返回true-1-1-float-1-1返回false" aria-hidden="true">#</a> 为什么程序里1==1.0返回true，1.1 = = (float)1.1返回false</h2><p>在比较基本类型的值的时候，实际上比较的是这个数转化为二进制后的值。十进制的数1.0、1.5、1.25等是整数或小数最后一位是5的，是可以准确用二进制数表示的，比如1.0或1用二进制表示出来都是1.0、1.5用二进制表示是1.1、1.25用二进制表示是1.01。</p><p>那么除了整数和最后一位是5的小数，其他小数呢？其他小数就是不能完整表示出来的了，比如0.1用二进制表示为0.00011001100110011…后面是0011的无限循环。</p><p>所以为什么1.1 = = (float)1.1 返回false呢，因为1.1是double类型，(float)1.1是float类型，double类型的精度为52位，对于0.1这样的无限循环就采取了截断，只写52位，float只写23位。所以他们就不相等了。比如0.00110011和0.00110是不相等的、0.0000和0.00是相等的。</p><h2 id="所有对象实例都存在于堆中吗" tabindex="-1"><a class="header-anchor" href="#所有对象实例都存在于堆中吗" aria-hidden="true">#</a> 所有对象实例都存在于堆中吗</h2><p>不是，这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p><h2 id="基本数据类型存放在栈中吗" tabindex="-1"><a class="header-anchor" href="#基本数据类型存放在栈中吗" aria-hidden="true">#</a> 基本数据类型存放在栈中吗</h2><p>不是，基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h2 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h2><div class="custom-container warning"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v4"></path><path d="M12 16h.01"></path></g></svg><p class="custom-container-title">WARNING</p><p>1.虽然 true, false, 和 null 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><p>2.移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。</p><p>3.关于基本类型占用多大空间的问题，对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。注意 char 在 Java 中占两个字节。</p><p>4.接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p><p>5.dd</p></div><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2>',23)),e("p",null,[e("a",f,[a[4]||(a[4]=r("byte类型取值范围为什么是127到-128？")),n(d)])]),e("p",null,[e("a",u,[a[5]||(a[5]=r("原码, 反码, 补码 详解")),n(d)])])])}const x=i(s,[["render",v],["__file","basic001.html.vue"]]);export{x as default};
