import{_ as n,r as d,c as i,o as t,a as o,b as a,f as h,d as l}from"./app-DukR-6js.js";const s={},p={href:"https://www.cnblogs.com/cjsblog/p/9379516.html",target:"_blank",rel:"noopener noreferrer"};function c(u,e){const r=d("ExternalLinkIcon");return t(),i("div",null,[e[1]||(e[1]=o('<h2 id="判断标准" tabindex="-1"><a class="header-anchor" href="#判断标准" aria-hidden="true">#</a> 判断标准</h2><p>一个是运行时间中可用状态占比，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的。 或者是用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 100 次，其中有 1 次请求失败，那么可用性就是 99%。</p><h2 id="如何提高系统可用性" tabindex="-1"><a class="header-anchor" href="#如何提高系统可用性" aria-hidden="true">#</a> 如何提高系统可用性</h2><p>对于普通开发者，最最首先要注意的就是代码质量，写出高质量的代码，尽量避免出现内存泄露、循环依赖等对系统产生极大危害的问题。 第二点就是在架构层面使用集群，避免单点故障。 第三点就是限流，避免在流量高峰系统被冲垮。 然后就是设置超时和重试机制，一旦用户请求超过某个时间的得不到响应，就抛出异常。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力。 超时和重试机制设置之外，熔断机制也是很重要的。 还有就是在一些瞬时流量很高的场景比如秒杀，使用消息队列异步调用也可以提高系统性能。 另外使用Redis等缓存服务也可以减轻数据库的压力。</p><h2 id="常见的限流算法" tabindex="-1"><a class="header-anchor" href="#常见的限流算法" aria-hidden="true">#</a> 常见的限流算法</h2><h3 id="固定窗口计数器算法" tabindex="-1"><a class="header-anchor" href="#固定窗口计数器算法" aria-hidden="true">#</a> 固定窗口计数器算法</h3><p>固定窗口其实就是时间窗口，其原理是将时间划分为固定大小的窗口，在每个窗口内限制请求的数量或速率，即固定窗口计数器算法规定了系统单位时间处理的请求数量。 缺点：限流不够平滑；无法保证限流速率；</p><h3 id="滑动窗口计数器算法" tabindex="-1"><a class="header-anchor" href="#滑动窗口计数器算法" aria-hidden="true">#</a> 滑动窗口计数器算法</h3><p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片 。</p><p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><p>缺点：</p><ul><li>与固定窗口计数器算法类似，滑动窗口计数器算法依然存在限流不够平滑的问题。</li><li>相比较于固定窗口计数器算法，滑动窗口计数器算法实现和理解起来更复杂一些。</li></ul><h3 id="漏桶算法" tabindex="-1"><a class="header-anchor" href="#漏桶算法" aria-hidden="true">#</a> 漏桶算法</h3><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p><p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。</p><p>缺点：</p><ul><li>无法应对突然激增的流量，因为只能以固定的速率处理请求，对系统资源利用不够友好。</li><li>桶流入水（发请求）的速率如果一直大于桶流出水（处理请求）的速率的话，那么桶会一直是满的，一部分新的请求会被丢弃，导致服务质量下降。</li></ul><p>实际业务场景中，基本不会使用漏桶算法。</p><h3 id="令牌桶算法" tabindex="-1"><a class="header-anchor" href="#令牌桶算法" aria-hidden="true">#</a> 令牌桶算法</h3><p>Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。</p>',20)),a("p",null,[a("a",p,[e[0]||(e[0]=h("令牌桶算法限流-博客园")),l(r)])]),e[2]||(e[2]=a("p",null,"生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。",-1))])}const m=n(s,[["render",c],["__file","program005.html.vue"]]);export{m as default};
