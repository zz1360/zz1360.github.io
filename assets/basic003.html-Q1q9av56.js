import{_ as e,c as d,o as l,a}from"./app-DukR-6js.js";const o={};function i(c,t){return l(),d("div",null,t[0]||(t[0]=[a('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th style="text-align:left;">基本类型</th><th style="text-align:left;">位数</th><th style="text-align:left;">字节</th><th style="text-align:left;">默认值</th><th>取值范围</th></tr></thead><tbody><tr><td style="text-align:left;"><code>byte</code></td><td style="text-align:left;">8</td><td style="text-align:left;">1</td><td style="text-align:left;">0</td><td>-128 ~ 127</td></tr><tr><td style="text-align:left;"><code>short</code></td><td style="text-align:left;">16</td><td style="text-align:left;">2</td><td style="text-align:left;">0</td><td>-32768（-2^15） ~ 32767（2^15 - 1）</td></tr><tr><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">32</td><td style="text-align:left;">4</td><td style="text-align:left;">0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:left;"><code>long</code></td><td style="text-align:left;">64</td><td style="text-align:left;">8</td><td style="text-align:left;">0L</td><td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td></tr><tr><td style="text-align:left;"><code>char</code></td><td style="text-align:left;">16</td><td style="text-align:left;">2</td><td style="text-align:left;">&#39;u0000&#39;</td><td>0 ~ 65535（2^16 - 1）</td></tr><tr><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">32</td><td style="text-align:left;">4</td><td style="text-align:left;">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td style="text-align:left;"><code>double</code></td><td style="text-align:left;">64</td><td style="text-align:left;">8</td><td style="text-align:left;">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td style="text-align:left;"><code>boolean</code></td><td style="text-align:left;">1</td><td style="text-align:left;"></td><td style="text-align:left;">false</td><td>true、false</td></tr></tbody></table><hr><h2 id="为什么byte的最小值可以取到-128" tabindex="-1"><a class="header-anchor" href="#为什么byte的最小值可以取到-128" aria-hidden="true">#</a> 为什么byte的最小值可以取到-128</h2><p>因为计算机存储的是二进制补码，最高位是符号位，所以一个8位二进制正数的取值范围是<code>0000 0000</code> 到 <code>0111 1111</code>，即0到127，负数的取值范围是<code>1000 0001</code> 到 <code>1111 1111</code>，即-1到-127。这时候还剩下<code>1000 0000</code>，如果表示-0是没有意义的，而且<code>0000 0000</code>也表示0，这样的话就是2个编码表示0了，二进制8位理论上可以表示256个数。根据运算规则，-1 和 -127的补码相加，刚好就是<code>1000 0000</code>，而-1 和 -127相加是-128，于是就用<code>1000 0000</code>表示-128.</p><h3 id="原码、反码和补码" tabindex="-1"><a class="header-anchor" href="#原码、反码和补码" aria-hidden="true">#</a> 原码、反码和补码</h3><ul><li>一个数在计算机中的二进制表示形式, 叫做这个数的机器数；</li><li>将带符号位的机器数对应的真正数值称为机器数的真值；</li><li>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值；</li><li>反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反；</li><li>补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1；</li></ul><h3 id="为什么机器要使用补码进行计算" tabindex="-1"><a class="header-anchor" href="#为什么机器要使用补码进行计算" aria-hidden="true">#</a> 为什么机器要使用补码进行计算</h3><p>对于人脑而言，是可以分辨符号位的，但是对于机器而言，辨别&quot;符号位&quot;显然会让计算机的基础电路设计变得十分复杂。 同时，两个正数的减法可以转换为一个正数和一个负数的加法，这样机器可以只有加法而没有减法。 在这种情况下，让符号位也参与计算的过程中，计算机运算的设计就可以更简单了。 当计算1-1的时候， 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的。 用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在&quot;0&quot;这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0。 于是补码的出现, 解决了0的符号以及两个编码的问题。0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128；</p><blockquote><p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p></blockquote><p>但是注意因为实际上是使用以前的-0的原码来表示-128的补码, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p><h3 id="另一种思路" tabindex="-1"><a class="header-anchor" href="#另一种思路" aria-hidden="true">#</a> 另一种思路</h3><p>因为 1000 0000 这个补码的存在，通过原有规则推出原码也是 1000 0000 ，也就是-0，明显是错误的，所以加一个规则； 规定：负数的补码 = 其对应正数按位取反 + 1。 1、1000 0000 最高位为 1，可以确定为负数 2、该负数对应的正数取反的值 = 1000 0000 - 1 = 0111 1111 3、该负数对应的正数 = 1000 0000 = 128 4、该负数表示的就是 -128 最后发现这个规定五好像推算更加简单，不用分两种情况了。比如我们直接推算所有负数： 1、1000 0000 ~ 1111 1111 最高位为 1，确定为负数 2、负数对应的正数取反的值 = 1000 0000 ~ 1111 1111 - 1 = 0111 1111 ~ 1111 1110 3、该负数对应的正数 = 1000 0000 ~ 0000 0001 = 128 ~ 1 4、该负数表示的就是 -128 ~ -1</p>',16)]))}const s=e(o,[["render",i],["__file","basic003.html.vue"]]);export{s as default};
