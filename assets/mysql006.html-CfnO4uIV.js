import{_ as t,c as i,o as e,a as l}from"./app-DukR-6js.js";const a={};function n(r,s){return e(),i("div",null,s[0]||(s[0]=[l('<h2 id="_12列的含义" tabindex="-1"><a class="header-anchor" href="#_12列的含义" aria-hidden="true">#</a> 12列的含义</h2><details class="custom-container details"><summary class="custom-container-title">id</summary><p>SELECT 查询的序列标识符。 用于标识每个 SELECT 语句的执行顺序。 id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p></details><details class="custom-container details"><summary class="custom-container-title">select_type</summary><p>SELECT 关键字对应的查询类型 主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p><ul><li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li><li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li><li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li><li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li><li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li><li><strong>UNION RESULT</strong>：UNION 查询的结果。</li></ul></details><details class="custom-container details"><summary class="custom-container-title">table</summary><p>用到的表名</p></details><details class="custom-container details"><summary class="custom-container-title">partitions</summary><p>匹配的分区，对于未分区的表，值为 NULL</p></details><details class="custom-container details"><summary class="custom-container-title">type</summary><p>表的访问方法，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li><li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><strong>ALL</strong>：全表扫描。</li></ul></details><details class="custom-container details"><summary class="custom-container-title">possible_keys</summary><p>可能用到的索引</p></details><details class="custom-container details"><summary class="custom-container-title">key</summary><p>实际用到的索引</p></details><details class="custom-container details"><summary class="custom-container-title">key_len</summary><p>所选索引的长度</p></details><details class="custom-container details"><summary class="custom-container-title">ref</summary><p>当使用索引等值查询时，与索引作比较的列或常量</p></details><details class="custom-container details"><summary class="custom-container-title">rows</summary><p>预计要读取的行数</p></details><details class="custom-container details"><summary class="custom-container-title">filtered</summary><p>按表条件过滤后，留存的记录数的百分比</p></details><details class="custom-container details"><summary class="custom-container-title">Extra</summary><p>附加信息。</p><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li><li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p></details>',13)]))}const c=t(a,[["render",n],["__file","mysql006.html.vue"]]);export{c as default};
